{
  "language": "Solidity",
  "sources": {
    "src/lib/TimeHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Uint256Helpers.sol\";\n\ncontract TimeHelpers {\n    using Uint256Helpers for uint256;\n\n    /**\n     * @dev Returns the current timestamp.\n     *      Using a function rather than `block.timestamp` allows us to easily mock it in\n     *      tests.\n     */\n    function getTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n    /**\n     * @dev Returns the current timestamp, converted to uint64.\n     *      Using a function rather than `block.timestamp` allows us to easily mock it in\n     *      tests.\n     */\n    function getTimestamp64() internal view returns (uint64) {\n        return getTimestamp().toUint64();\n    }\n}\n"
    },
    "src/lib/Uint256Helpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary Uint256Helpers {\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(\n            value <= type(uint64).max,\n            \"SafeCast: value doesn't fit in 64 bits\"\n        );\n        return uint64(value);\n    }\n}\n"
    },
    "src/RosetteStone.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./lib/TimeHelpers.sol\";\n\ncontract RosetteStone is TimeHelpers {\n    error InvalidEntry(bytes32 scope, bytes4 sig, bytes cid);\n\n    enum EntryStatus {\n        Empty,\n        Added\n    }\n\n    struct Entry {\n        uint64 upsertAt; // Blocktime at which entry was upserted\n        bytes cid; // IPFS CID of the file containing the entry data\n        address submitter; // Address that upserted the entry\n    }\n\n    /**\n     * A nested mapping of scope -> sig -> entry.\n     */\n    mapping(bytes32 => mapping(bytes4 => Entry)) private entries;\n\n    // /////////////////////// MODIFIERS ////////////////////////////////////////////////////////////////////////\n\n    modifier validEntry(\n        bytes32 _scope,\n        bytes4 _sig,\n        bytes memory _cid\n    ) {\n        if (_scope == bytes32(0) || _sig == bytes4(0) || _cid.length == 0) {\n            revert InvalidEntry(_scope, _sig, _cid);\n        }\n        _;\n    }\n\n    // ////////////////////////// EVENTS ///////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Emitted when an entry is inserted or updated.\n     * @param scope The contract's bytecode hash.\n     * @param sig The signature of the method the entry is describing.\n     * @param submitter The address that upserted the entry.\n     * @param cid The IPFS CID of the file containing the Radspec description.\n     */\n    event EntryUpserted(\n        bytes32 indexed scope,\n        bytes4 indexed sig,\n        address submitter,\n        bytes cid\n    );\n\n    /**\n     * @dev Emitted when an entry is removed.\n     * @param scope The contract's bytecode hash.\n     * @param sig The signature of the method the entry is describing.\n     */\n    event EntryRemoved(bytes32 indexed scope, bytes4 indexed sig);\n\n    // /////////////////////// CONSTRUCTOR //////////////////////////////////////////////////////////////////////\n\n    constructor() {}\n\n    // ///////////////////// EXTERNAL ///////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Upsert a registry entry.\n     * @param _scope The contract's bytecode hash.\n     * @param _sig The signature of the method the entry is describing.\n     * @param _cid The IPFS CID of the file containing the description.\n     */\n    function upsertEntry(\n        bytes32 _scope,\n        bytes4 _sig,\n        bytes memory _cid\n    ) public payable validEntry(_scope, _sig, _cid) {\n        EntryStatus status = _entryStatus(_scope, _sig);\n        if (status == EntryStatus.Added) {\n            Entry storage entry_ = entries[_scope][_sig];\n            require(\n                entry_.submitter == msg.sender,\n                \"RosetteStone: not authorized address\"\n            );\n        }\n\n        _upsertEntry(_scope, _sig, _cid, msg.sender, getTimestamp64());\n    }\n\n    /**\n     * @dev Upsert a list of entries.\n     * @param _scopes The list of contract's bytecode hash.\n     * @param _sigs The list of function signatures.\n     * @param _cids The list of IPFS CIDs of the file containing the description.\n     */\n    function upsertEntries(\n        bytes32[] memory _scopes,\n        bytes4[] memory _sigs,\n        bytes[] memory _cids\n    ) external payable {\n        for (uint256 i = 0; i < _scopes.length; i++) {\n            upsertEntry(_scopes[i], _sigs[i], _cids[i]);\n        }\n    }\n\n    /**\n     * @dev Get an entry from the registry.\n     * @param _scope The contract's bytecode hash.\n     * @param _sig The signature of the method the entry is describing.\n     * @return The CID, submitter, and status of the entry.\n     */\n    function getEntry(bytes32 _scope, bytes4 _sig)\n        external\n        view\n        returns (\n            bytes memory,\n            address,\n            EntryStatus\n        )\n    {\n        Entry memory entry_ = entries[_scope][_sig];\n        return (entry_.cid, entry_.submitter, _entryStatus(_scope, _sig));\n    }\n\n    /**\n     * @dev Remove an entry from the registry.\n     * @param _scope The contract's bytecode hash.\n     * @param _sig The signature of the method the entry is describing.\n     */\n    function removeEntry(bytes32 _scope, bytes4 _sig) public {\n        Entry memory entry_ = entries[_scope][_sig];\n        require(\n            entry_.submitter == msg.sender,\n            \"RosetteStone: not authorized address\"\n        );\n\n        _removeEntry(_scope, _sig);\n    }\n\n    /**\n     * @dev Remove a list of entries.\n     * @param _scopes The list of contract's bytecode hash.\n     * @param _sigs The list of function signatures.\n     */\n    function removeEntries(bytes32[] memory _scopes, bytes4[] memory _sigs)\n        external\n        payable\n    {\n        for (uint256 i = 0; i < _scopes.length; i++) {\n            this.removeEntry(_scopes[i], _sigs[i]);\n        }\n    }\n\n    // ///////////////////////// INTERNAL //////////////////////////////////////////////////////////////////////\n\n    function _upsertEntry(\n        bytes32 _scope,\n        bytes4 _sig,\n        bytes memory _cid,\n        address _submitter,\n        uint64 _upsertAt\n    ) internal {\n        Entry storage entry_ = entries[_scope][_sig];\n        entry_.upsertAt = _upsertAt;\n        entry_.cid = _cid;\n        entry_.submitter = _submitter;\n\n        emit EntryUpserted(_scope, _sig, _submitter, _cid);\n    }\n\n    function _removeEntry(bytes32 _scope, bytes4 _sig) internal {\n        delete entries[_scope][_sig];\n        emit EntryRemoved(_scope, _sig);\n    }\n\n    /**\n     * @dev Get the current status of an entry.\n     * @param _scope The contract's bytecode hash.\n     * @param _sig The signature of the method the entry is describing.\n     * @return The current EntryStatus\n     */\n    function _entryStatus(bytes32 _scope, bytes4 _sig)\n        internal\n        view\n        returns (EntryStatus)\n    {\n        Entry memory entry_ = entries[_scope][_sig];\n        if (entry_.submitter == address(0)) {\n            return EntryStatus.Empty;\n        }\n\n        return EntryStatus.Added;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}